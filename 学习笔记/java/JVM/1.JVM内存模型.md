# JVM内存模型

[内存模型](https://www.processon.com/view/5e9552915653bb1a686134c9?fromnew=1)

## 程序计数器

* 线程私有化

  ​	jdk1.8默认采用的是hotspot VM，hotspot VM采用的原型是1:1（一个java线程对应一个OS线程），多个java线程在一个OS线程执行时，由于CPU的碎片化执行方式，会让多个java线程轮训执行。倘若一个线程执行到字节码的某一行时，cpu切换到另一个线程，这时需要程序计数器记录下java线程的字节码行数。所以每个线程都有自己独立的程序计数器。

* 不存在OOM

  ​	由于每个java文件编译后的字节码行数是固定的，所以一开始分配内存时，就会给出足够的内存。

* 执行native方法时，程序计数器的值为空

  ​	native是调用c语言库来执行的，所以也就不记录字节码行数了

  ​	[Java多线程执行native方法时程序计数器为空，那么线程切换后如何找到之前执行到哪里了](https://www.zhihu.com/question/40598119/answer/87381512)

## 虚拟机栈

​		![image-20201215154940141](C:\Users\kgcaox\AppData\Roaming\Typora\typora-user-images\image-20201215154940141.png)

​		虚拟机栈是一个后入先出的栈，有多个栈帧组成，每个栈帧里面会存放着数据和部分过程结果的数据结构，以及用来处理动态连接、方法的返回值和异常分派。由于栈先入后出的规则，所有虚拟机栈只有一个栈帧处于活跃状态（当前活跃栈帧），当前活跃栈帧位于虚拟机栈的顶部。

### 			功能

> * 局部变量
>
>   ​	存放着数据的基本类型以及对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)
>
> * 操作数栈
>
>   ​	  操作数栈也常被称为操作栈，它是一个后入先出栈。JVM底层字节码指令集是基于栈类型的，所有的操作码都是对操作数栈上的数据进行操作，对于每一个方法的调用，JVM会建立一个操作数栈，以供计算使用。和局部变量一样。操作数栈的最大深度也是编译的时候写入到方法表的code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long、double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个“字宽”占4个字节，64位虚拟机来说，一个“字宽”占8个字节。当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。
>
> * 动态连接
>
>   ​	每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。
>
> * 方法返回地址
>
>   ​	当一个方法执行时，有两种方式退出。第一种是正常完成出口，当方法执行完成之后，会有一个返回值传递给调用者，根据此时是否有返回值以及返回值的类型，来判断以哪种方式退出；第二种是异常完成出口，当方法执行的过程中出现异常的时候，就会退出。两者的后续区别在于，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。而且一旦方法退出后，就相当于方法出栈了，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。

### 		特点

> * 线程私有化，生命周期与线程一致
> * 异常：StackOverflowError（线程请求的栈深度已经超过操作数栈的max_stacks），OutofMemoryError（超过了虚拟机可分配的最大内存）

## 本地方法栈(C栈)

​	通过native关键字，调用C函数库，其结构与虚拟机栈类似，具体的调用模型如下：

![image-20201215175947859](C:\Users\kgcaox\AppData\Roaming\Typora\typora-user-images\image-20201215175947859.png)

## 虚拟机堆

### 功能
> * 堆内存：我们日常new对象实例和数组实例的时候，便是在这个上面new一段内存进行存储，但是被final修饰之后的变量也好，常量也好，都会在堆内存中
>
> * 内存模型（j8以后，方法区称之为元空间）
>
>   ​	Eden区：一般情况下，刚创建的对象都会被分配到Eden区，大的对象会被分配进old区
>
>   ​	Survivor区：Survivor区分为S0和S1区，在同一时间内，S0和S1只会有一个区有数据，另一个区为空
>
>   ​	Old区：当GC一定次数后还存活的对象，会被移到Old区
>
>   ​	Eden区占比：8：1：1
>
>   
>
> ![image-20201225110537909](C:\Users\kgcaox\AppData\Roaming\Typora\typora-user-images\image-20201225110537909.png)
>
> * 数据流向
>
> ![image-20201225114952562](C:\Users\kgcaox\AppData\Roaming\Typora\typora-user-images\image-20201225114952562.png)

### 特点

	* 线程共享
	* 在物理上储存是不连续的，但是在逻辑上必须是连续的
	* 内部有多个线程私有的分配缓冲区

## 方法区（元空间）

## Object对象

## 直接内存

